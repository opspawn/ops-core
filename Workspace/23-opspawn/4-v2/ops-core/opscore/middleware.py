# opscore/middleware.py
"""
Middleware for the Ops-Core FastAPI application.

Includes middleware for:
- Structured request/response logging.
- Standardized error handling.
"""

import time
import logging
import traceback
from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.types import ASGIApp
from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR

from .exceptions import OpsCoreError, get_status_code_for_exception
from .logging_config import setup_logging

# Ensure logging is configured when this module is imported
setup_logging()
logger = logging.getLogger(__name__)


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """
    Middleware to log incoming requests and outgoing responses.

    Logs request details (method, path, client) and response details
    (status code, processing time).
    """
    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        """
        Process the request and log details before and after.

        Args:
            request: The incoming request.
            call_next: The next middleware or endpoint in the chain.

        Returns:
            The response generated by the endpoint.
        """
        start_time = time.time()
        client_host = request.client.host if request.client else "unknown"
        client_port = request.client.port if request.client else "unknown"

        logger.info(
            "Incoming request",
            extra={
                "method": request.method,
                "path": request.url.path,
                "client": f"{client_host}:{client_port}",
            },
        )

        response = None # Initialize response to None
        status_code = HTTP_500_INTERNAL_SERVER_ERROR # Default to 500 for logging if error occurs before response
        try:
            response = await call_next(request)
            status_code = response.status_code # Get actual status code from response
            process_time = time.time() - start_time
            response.headers["X-Process-Time"] = str(process_time) # Optional: Add header

            logger.info(
                "Outgoing response",
                extra={
                    "method": request.method,
                    "path": request.url.path,
                    "status_code": status_code,
                    "process_time_ms": round(process_time * 1000, 2),
                },
            )
            return response
        except Exception as e:
            # Let the ErrorHandlerMiddleware handle the actual error response generation
            # and specific logging. We just log that an error occurred during processing.
            process_time = time.time() - start_time
            # Use the status_code determined by ErrorHandlerMiddleware if possible,
            # otherwise stick to the default 500 for this log entry.
            # Note: This logging happens *before* ErrorHandlerMiddleware creates the final response.
            if isinstance(e, OpsCoreError):
                 status_code = get_status_code_for_exception(e)

            logger.info(
                "Outgoing response (error occurred)",
                 extra={
                    "method": request.method,
                    "path": request.url.path,
                    "status_code": status_code,
                    "process_time_ms": round(process_time * 1000, 2),
                },
            )
            # Re-raise the exception to be caught by the ErrorHandlerMiddleware
            raise e


class ErrorHandlerMiddleware(BaseHTTPMiddleware):
    """
    Middleware to catch exceptions and return standardized JSON error responses.

    Catches OpsCoreError subclasses and maps them to appropriate HTTP status
    codes and responses. Catches generic Exceptions and returns a 500 error.
    """
    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        """
        Process the request and handle exceptions.

        Args:
            request: The incoming request.
            call_next: The next middleware or endpoint in the chain.

        Returns:
            The response, potentially a JSONResponse if an error occurred.
        """
        try:
            response = await call_next(request)
            return response
        except OpsCoreError as e:
            status_code = get_status_code_for_exception(e)
            error_detail = str(e)
            logger.error(
                "OpsCoreError occurred: %s", error_detail,
                exc_info=True, # Include traceback in log
                extra={
                    "error_type": type(e).__name__,
                    "status_code": status_code,
                    "method": request.method,
                    "path": request.url.path,
                }
            )
            return JSONResponse(
                status_code=status_code,
                content={"detail": error_detail},
            )
        except Exception as e:
            # Catch any other unexpected errors
            tb_str = traceback.format_exc()
            error_detail = "Internal Server Error"
            logger.critical(
                "Unhandled exception occurred: %s", str(e),
                exc_info=True, # Include traceback in log
                extra={
                    "error_type": type(e).__name__,
                    "status_code": HTTP_500_INTERNAL_SERVER_ERROR,
                    "method": request.method,
                    "path": request.url.path,
                    "traceback": tb_str # Log the full traceback
                }
            )
            return JSONResponse(
                status_code=HTTP_500_INTERNAL_SERVER_ERROR,
                content={"detail": error_detail},
            )